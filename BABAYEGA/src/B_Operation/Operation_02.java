package B_Operation;

public class Operation_02 {
	public static void main(String[] args){
		/*
		
		1. 증감연산자( ++, --):단항 연산자에서는 어느 위치에 있어도 관계없다.
		 				   :
			-증가 연산자(++) : 피연산자의 값을 1증가시킨다.
			-감소 연산자(--) : 피연산자의 값을 1감소시킨다.
			
			
			 
			    */
		
		int i1 = 50;
		i1++;
		System.out.println(i1);
		++i1;
		System.out.println(i1);
		++i1;
		System.out.println(i1);
		
		int i2 = 10;
		int i3 = ++i2 + 5;
		
		System.out.println(i2);
		System.out.println(i3);
		System.out.println(i2 + ":"+ i3);
		
		int i4 = 11;
		int i5 = 6 + i4++; //단항 연산자가 아닐경우, 증감연산자가 항의 뒤편에 존재하면 연산을 행하지 않고 그대로의 값을 더하고, 그 다음에 i4는 12가 된다.
		
		System.out.println(i5 + ":" + i4); // 6+ 11 = 17
		System.out.println(i4); // 위의 연산이 끝난 후 i4는 ++이 연산되어 i4 = 12 가 된다.
		
		int i6 = 20;
		int i7 = 30;
		int i8 = ++i6 + 5 + i7++ + i6++; // i6는 +1 해서 21, 계산하면 21+30+21+5= 77, 계산식이 끝나면 i6 = 22, i7 = 31
		System.out.println(i6 + ":" + i7);
		System.out.println(i6 + ":" + i7 + ":" + i8);
		
		
		//** i8의 계산식이 연산되지 않았어도, i6의 값은 계산식이 모두 종료되었을때의 증감값을 갖는다.**
		
		/*
		 
		 2.비트(bit,2진수)전환 연산자 ( ~ :틸트)
		 	-정수형과 char형에만 사용할 수 있다. (실수 x)
		 	-피연산자를 2진수로 표현했을 때 0은 1로, 1은 0으로 변경해준다.(2진수로 바꿔라) 
		
		
		byte b = 10;// b = 00001010(2) = 10 -> ~b  = 11110101(2) = -11
		            //   첫번째 부호가 양수인 0일때 = 0 + 10             첫번째 부호가 음수인 1일때 = -128 + 117(보수) = -11  
					// 10의 1의 보수는 -11, 2의 보수는 -10, -504의 1의 보수는 503, 2의 보수는 504     
					// ~ b (?)
			
         		
		*/
		byte b1 = 10;
		int i10 = ~b1;
		System.out.println(i10); // 10의 1의 보수가 나옵니다. 2의 보수는?
		
		
		/*
		 3.논리부정 연산자(!)
		 -boolean형에만 사용 가능하다.
		 -true -> false, false -> true
		 
		 
		 
		 power변수를 선언하고 true의 값으로 초기화하세요
		 */
		
		boolean power = true;
		power = !power; // 초기값 = 계산해야할 리터럴값  형태를 띄어야한다.
		System.out.println(power);
		//-> 
		
		/*
		4.산술연산자
			-사칙연산자(+-/*), 나머지연산자(%), 쉬프트연산자(<<,>>,>>> -화면 이동하는데 사용함-)
			-이항연산자는 피연산자의 크기가 4byte보다 작은 데이터들의 연산시에는 4byte형인 int형으로 변환 후에 연산을 수행한다.
			
		5.사칙연산자(규칙)
			- int형(4byte)보다 작은 자료형은 int형으로 형변환 후에 연산을 진행한다.
			- 두개의 피연산자중 자료형의 표현 범위가 큰쪽에 맞춰서 형변환 후에 연산을 한다.
			- 정수형 값을 0으로 나누는 것은 금지되어 있다.(에러발생, / by zero 라는 에러메세지가 뜬다.)
			
			
		*/
		
		//1)byte 타입의 변수에 10의 값으로 초기화해 주세요.(aa1)
		byte aa1 = 10;
		//2) short 타입의 변수 aa2에 250의 값으로 초기화해 주세요.(aa2)
		short aa2 = 250;
		//3) aa1과 aa2의 합을 저장할 수 있는 result변수를 선언해주세요.(result)
		int result = aa1 + aa2; //int보다 작은 자료형은 int형으로 형변환 후에 연산을 진행하기 때문에 int보다 작은 자료형인 byte(aa1), short(aa2)는 사칙연산시 int값으로 형변환된다.
		                        //따라서 두 피연산자는 int값이 되고, 이를 합하는 값이 저장되는 변수값은 int형의 변수밖에 안된다.
	    //4) 3.141592를 저장할 수 있는 변수를 선언 및 초기화해주세요 (aa3)
		float aa3 = 3.141592f;
		//5) aa3와 aa1의 합을 저장할 수 있는 result2변수를 선언 및 초기화해주세요.
		float result2 = aa1 + aa3;
		System.out.println(result2);
		//6) '초' 글자와 '연' 글자의 합계를 구해주세요 result3// int 아래에 위치한 char로 된 두 연산자는 결국 int형으로 형변환된다.
		int result3 = '초' + '연';
		System.out.println(result3);
		
		//7)
		int aaa = 10;
		int bbb = 20;
		int result4 = aaa/ bbb;
		System.out.println(result4); // 여기서 10/20은 0.5라는 답이 나와야 하는데 소수점을 표현할 수 없는 int이기 때문에 여기서 소수점이 나오려면
		
		int aab = 10;
		int bba = 20;
		float result5 = (float) aab/bbb;
		System.out.println(result5); // 형변환 (float)으로 aab를 float
		
		/*
		6. 나머지 연산자 (%)
		-왼쪽의 피연산자를 오른쪽의 피연산자로 나누고 나온 나머지 값을 들려준다.
		-boolean형(논리형)을 제외한 모든 기본형 변수에 사용할 수 있다.
				
		*/
		//1)변수 ab1에 10의 값을 저장해주세요
		int ab1 = 10;
		//2)변수 ab2 에 8의 값 저장
		int ab2 = 8;
		//3)변수 share에 ab1을 ab2로 나눈 결과를 저장해주세요
		float share2 = (float)ab1/ ab2;// 1 - > 
		//4)변수 remain에 ab1을 ab2로 나누고 난 나머지 값을 저장해주세요.
		
		int remain = ab1%ab2; // 2 ->
		 // <- 3)
		
		System.out.println(share2); //1.25
		
		System.out.println(ab1+"을 " + ab2 + "로 나눈 몫은 " + share2 +"이고 나머지는 "+ remain + "이다");
		

		
		/*
		 7. 쉬프트 연산자 (<< , >> , >>>)
		 -정수형 변수에만 사용 가능하다.(byte)
		 -피연산자의 각자리(2진수)를 오른쪽 또는 왼쪽으로 이동한다.
		 - << x 일때는 2의 x제곱을 '곱하면' 됩니다.
		 - >> y 일때는 2의 y제옵을 '나누면' 됩니다.
		 
		 **곱셈과 나눗셈을 할때 연산 속도가 빠르기 때문에 사용된다.**
		 - << : x << n  // x*2^n의 결과와 같다. (overflow를 조심해야한다.)
		 - << : x >> n  // x/2^n의 결과와 같다. (음수로 넘어가지 않기 때문에[아무리 나눠도 0보다는 크기 때문에] 
		                                    byte가 정수타입이기 때문에 소수점이 발생하지 않고, overflow가 발생하지 않는다..)
		 
		 
		 -10<<11= 10 * 2^11 (byte의 오버플로우는 = 8) => 10 * 2^(11-8 = 3 ) = 10 * 2^3 = 80 (계산의 한계가 존재하기 때문에 일어나는 현상) 
		 -int type으로 바꾸면 372 *  2^32 * 2^1 [int의 오버플로우는 32] = 371 * 1 (오버플로우) * 2^1 = 744 (계산의 한계가 존재하기 때문에 일어나는 현상)

		 10<<2 = 10 * 2^2 = 40
		 10<<3 = 10 * 2^3 = 80
		 
		 10>>2 = 10 / 2^2 = 2
		 10>>3 = 10 / 2^3 = 1
			 
			 
			 
		8. 비교연산자
		 - 두 개의 변수 또는 리터럴을 비교하는데 사용되는 연산자.
		 - 주로 조건문과 반복문의 조건식에서 사용되며 true와 false의 결과만 갖는다.
		 - 이항연산자이다.(최소변수형태는 int다)
		 
		 
		 9. 대소비교 연산다(<,>,<=,>=)
		 -기본형중에 bloolean형을 제외한 나머지 자료형에 사용 가능하다.
		 -참조형에는 사용할 수 없다.
		 
		 10. 등가비교연산자( ==, !=)
		 -모든 자료형에서 사용할 수 있다.(기본형 , 참조형 모두 가능) = 조건문에 중요함.
		 
		      수식                          연산결과
		   x > y                x가 y보다 클때 true, 작으면 false  
		   x < y                x가 y보다 클때 false, 작으면 true
		   x >= y               x가 y보다 크거나 같을때 true 그 외에는 false이다
		   x <= y               x가 y보다 작거나 같을때 true 그 외에는 false이다
		   x == y				x와 y가 같을때 true, 다르면 false이다
		   x != y               x와 y가 다르면 true, 같으면 false이다
		 
		
		 
		 
		 */
		
          //문제 3- 6번
			
		int abc = 64;
		
		System.out.println(((abc - (abc % 10))+ 10)-abc);//   (
		
		/*
		11.비트연산자 ( &, |, ^) - 논리회로에 자주 쓰임.
		- 이진 비트 연산을 수행한다.
		- 실수형을 제외한 모든 기본형에서 사용할 수 있다.
		
		-&(and연산자) : 피연산자 중 양쪽 모두의 값이 1이면 1의 결과를 얻는다.  1:1 = 1
		-|(or 연산자) : 피연산자 중 한쪽의 값이 1이면 1의 결과를 얻는다.     1:1 = 1  / 1:0 = 1 / 0 : 1 = 1/ 0 : 0 = 0 
		-^(xor연산자) : 피연산자의 값이 모두 다를때 1의 결과를 얻는다.       1:1 = 0  / 1: 0 = 1 / 0 :1 = 1 / 0 :0 = 0
		
		3 - > 00000011
		5 - > 00000101
		
		
		3^5 ->00000110 = 6
		3|5 ->00000111 = 7
		3&5 ->00000001 = 1 
		
		
	    */
		/*
		12.논리연산자 ( &&,||)
		- 피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용한다.(0,1 ,true, false)
		- 0<= x >= 15 를 표현하려면 0 <= x && x >= 15  
		-'&&'연산이 '||'연산보다 우선순위가 높다.(&&와 ||이 동시에 있을때 &&를 먼저 계산한다, 덧셈 뺄쌤 곱셈 나눗셈의 연산순서랑 같다)
		-||결합 : 피연산자 어느 한쪽만 true이면 ture의 결과를 얻는다.
		-&&결합 : 피연산자 양쪽 모두 true일때만 true이다.
		
		*/
		//1. 'J'를 저장할 수 있는 변수 ab4를 선언 및 초기화 해 주세요
		char ab4 ='1';
		//2.ab4의 값이 대문자 일때 true의 결과를 얻는 조건식을 만드세요.
		
		 System.out.println('A'<=ab4&& ab4<='Z');
		 System.out.println('a'<=ab4&& ab4<='z');
		 System.out.println('A'<=ab4&& ab4<='Z' || 'a'<=ab4&& ab4<='z');
	     System.out.println('0'<= ab4&& ab4<='9');
	     System.out.println('A'<=ab4&& ab4<='Z'||'a'<=ab4&& ab4<='z'||'0'<=ab4&& ab4<='9' );//'A' -> 'Z'  <사이에 특수문자> 'a' -> 'z' , '0' -> '9'
	
	     
	     /*
			13. 삼항 연산자
			-세 개의 피연산자를 필요로 하기 때문에 삼항연산자라고 한다.
			-조건식 ? 
			-( x? y(식) : z(식) ) 조건식 ? true 실행 : false 실행
			
			14. 반올림
			math.ceil()
			math.			
			math.ground()
						
	     */
	     float x2 = 37.6543f;
	     float x3 = (int)(x2*1000+0.5)/1000f;   // 소수 넷째자리에서 올림하는 식이기 때문에 1000을 넣었다. 원하는 자릿수만큼 넣으면 됩니다.  
	     System.out.println(x3);
	     
	     int result10 = (int)( x2 + 0.5);
	     System.out.println(result10);	   
	     
	     float x10 = 37.1547f;
	     int x11 = (int)(x10 * 1000+0.5);
	     float result14 = x11 / 1000f;
	     System.out.println(result14);  //캐스팅 변환을 통해서 원하는 소수점 자리를 표현할 수 있다.
	     
	     //1) 37.1568 소수점 넷째자리에서 반올림하여 셋째자리까지 표현하세요
	     
	     /*
	      15.random
	      
	      
	      
		     */
		     int result515 = (int)(Math.random()*17
		    		 +1);
		     System.out.
		     
		     println(result515);
		     // Math<- 자바 내의 클레스 , random <- 매써드 0<= Math.random() < 1 [double 타입] 
		     //형태 =  (int)(math.ramdon()*(랜덤값-1)+1(시작값))
		     
		     //주사위 1~6
		     //포함 ~ 미포함 -> 1~7
		     //뒤- 앞 = 6
		     //시작    = 1
	     
	     /*16. 대입연산자 (= , op= )
	     
	     aab = aab + 5;
	     aab += 5;
	     aab *= 5;
	     aab %= 5;
	     
	     
	     */
	}  
}
