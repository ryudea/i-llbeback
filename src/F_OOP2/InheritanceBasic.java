package F_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {

		/*
		  1. 상속 (is a : ~은 ~이다.)
		  
		  
		  -> 직사각형은 사각형이다. -> 작은 개념은 큰 개념이다.(o) -> 큰 개념은 작은 개념이다.(x) -> 자동차의 기본
		  골격과 같이 변하지 않을 공통부분을 '부모'로 -> 자동차의 특징, 옵션등 부가적으로 변하는 부분들을 '자식'으로 두고
		  상속관계를 둔다.
		  
		  ->적은 양의 코드로 새로운 클레스를 작성할 수 있다. ->새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의
		  이름을 키워드'extends'를 함께 서 주기만 하면 된다. -> ex ) class Child extends Parent{
		  /..... } -상속을 주는 클레스: 조상클래스, 부모 클래스, 상위 클래스, 기반클래스. -상속을 받는 클레스:
		  자손클래스, 자식 클래스, 하위 클래스, 파생된 클래스.
		  
		  자손 클래스
		  
		  ->'맴버'만 상속받는다. ->자손 클래스의 맴버의 개수는 조상 클래스보다 같거나 많다.
		  
		  
		  
		  
		  2. 포함 (has a : ~은 ~을 포함하고 있다.)
		  
		  
		  -> 원은 점을 포함하고 있다. -> 큰개념은 작은개념을 포함하고 있다.(o) -> 작은 개념은 큰개념을 포함하고
		  있다.(x)
		  
		  -> 상속 이외의 클레스를 재사용하는 방법 -> 한 클래스의 맴버변수로 다른 클래스를 선언하는 방법이다.
		  
		  
		  3.단일상속 - 자바에서는 단일상속만 가능하다(2개 이상의 상속은 불가능하다. = 하나의 부모만을 갖는다.) 
		  class TVCR extends Tv, VCR { //불가능 } -TV와 VCR에 동일한 맴버가 있을때 어떤것을 상속받을지 알 수
		  없다. -VCR의 맴버명을 바꾼다면 그동안 VCR의 맴버를 사용하던 부분들을 모두 수정해주어야한다. -클레스간의 관계가 보다
		  명확해지고 코드를 더욱 신뢰할 수 있다.
		  
		  4.Object 클레스(모든 class의 조상) - 모든 클레스의 상속 계층도의 가장 위에 위치하는 조상 class - 다른
		  클레스로부터 상속받지 않는 클레스들은 자동적으로 Object 클레스를 상속받습니다. ex)) class Tv{} ==
		  class Tv extend Object{ Tv(){ super();}}
		  
		  -toString()나 equals()와 같은 메서드를 따로 정의하지 않고 사용할 수 있는 것은 Object class에
		  정의된 것들이기 때문이다.
		  
		  5.오버라이드(over ride) - 조상 class로부터 상속받은 매서드의 내용을 변경하는 것(= 재 정의). -
		  오버라이드가 되기 위한 조건 1)선언부가 부모의 것과 자식의 것이 일치해야 한다. ex) public String
		  toString <호출시 부모것이 아닌 자식것을 먼저 부른다.> :자손 class에서 over ride하는 매서드는
		  조상클레스의 매서드의 명과 동일해야한다. :매개변수의 타입과 개수가 같아야 한다. :'같은 타입과 변수 개수'를 받은 후 <
		  선언>, 그것을 '구현'하는 방식을 다르게 줘서 다른 결과값(내가 원하는 결과값) 을 얻어내서 반환받은 것을 의미한다. 이때
		  리턴타입이 같아야한다. :우선순위는 자손 class > 조상 class 이기 때문에 자손 class에서 오버라이딩한 메서드가
		  우선적으로 구현된다. :접근제어자를 조상 클레스보다 좁은 범위로 설정할 수 없다. :예외는 조상 class의 메서드보다 많이
		  선언할 수 없다.
		  
		  6.super. -조상 클레스의 맴버와 자손클레스의 맴버가 중복정의되어 있을때 서로 구분하기 위해 사용 -조상맴버와
		  자신(자식)의 맴버를 구별하는데 사용된다는 것을 제외하고는 this.와 근본적으로 동일한 참조변수이다.
		  -static매서드(class method)에서 사용할 수 없다.
		  
		  7.super() - 조상 class의 생성자를 호출 - this()와 마찬가지로 super() 역시 생성자를 호출하는
		  것이다. - this()는 같은 클레스의 다른 생성자를 호출, super()는 부모 class의 생성자를 호출. - 생성자의
		  첫 줄에는 조상 클레스의 생성자를 호출해야 한다. - 자손 class의 맴버가 조상 class의 맴버를 사용할 수 있음으로
		  조상의 맴버들이 먼저 초기화되어야한다.
		  
		  
		  8.제어자 - 클레스, 변수 메서드의 선언부에 사용된다. - 접근 제어자와 그 외 제어자로 나뉘어진다. - 접근제어자란
		  :private(class) < default(같은 package) < protected < public(sorce) -
		  그외 제어자 :static , final, abstract , native ...
		  
		  - 두 제어자를 같이 쓸때는 접근 제어가 맨 왼쪽에 두는게 보편적이다.
		  
		  1-1)static(클레스의, 공통적인) : 맴버변수, 매서드, 초기화 블럭에 사용된다.
		  
		  : static 변수 -> 모든 인스턴스에서 공통적으로 사용되는 변수에 static을 붙인다. -> 인스턴스화를 하지 않고도
		  호출 가능하다.(클레스명을 이용해서) -> 클레스가 메모리에 로드될때 생성된다. : static 메서드 -> 변수와
		  동일하다. -> 클레스 메서드 내에서 인스턴스 맴버를 호출할 수 없다.
		  
		  : final (변경할 수 없는 ) -> 변수에 사용시 상수가 된다. -> 매서드에 사용시 오버 라이드가 안된다.(재정의를
		  할 수가 없다.) -> 클레스에 사용시 상속할 수 없는 클레스가 된다.
		  
		  :abstract(추상의, 미완성된) -> 변수에서는 사용이 불가능하다. -> 매서드와 클레스에서 사용가능하다. ->
		  메서드에 사용시 구현부는 작성하지 않는다. ex) void method(); for();
		  
		  9. 접근 제어자 - private:같은 class 내에서만 접근할 수 있게 하는 접근제어자, class를 제외한 변수,
		  메서드 앞에 붙인다. - default:class 앞에 붙일 수 있는 접근제어자, 패키지 내에서 사용할 수 있다.(패키지
		  내에서 다 생략되어 있다.) - protected: 같은 패키지 + 다른 패키지의 자손 클레스에서 접근 가능. -
		  public:접근 제한이 없다(project 내에서 다 사용가능), class 앞에 붙일 수 있는 접근 제어자.
		  
		  -클레스 앞에는 default와 public만 사용가능하다. -변수와 메서드 앞에는 접근제어자를 모두 쓸 수 있다.
		  
		  10.캡슐화 - 접근제어자를 사용하는 이유 :외부로 부터 데이터를 보호하기 위한 목적 :외부에는 불필요한, 내부적으로만
		  사용되는 부분을 감추기 위해 사용(보안을 위해 사용된다.)
		  
		  11.다형성(polymorphism) - 여러가지 형태를 가질 수 있는 능력 - 한 타입의 참조 변수로 여러 타입의 객체를
		  참조할 수 있다. Car c = new FireCar(); Car c = new Ambulance(); - 부모타입의
		  참조변수로 자손 타입의 인스턴스를 참조할 수 있다. <- 다형성의 가장 큰 특징 - 자손타입의 참조변수로 부모 타입의
		  인스턴스를 잠조할 수 없다.(둘다 인스턴스화를 하지 않았다는 전제하에)
		  
		  
		  
		  12. 참조변수의 형변환(상속) - 서로 상속관계에 있는 클레스에서만 형변환이 가능하다.
		  
		  - 자손타입 - > 부모타입 (up-casting) : 형변환 생략
		  
		  - 부모타입 - > 자손타입 (down-casting) : 형변환 생략 불가.
		  
		  13. instanceof(형변환이 가능한가 아닌가를 판한다는 기준)
		   - 참조변수가 참조하고 있는 인스턴스의 실제타입을
		  알아보기 위해 사용합니다. - 연산결과가 true이면 참조변수가 검사한 타입으로 형변환이 가능하다. 
		  - 클레스 메서드와 클레스 변수는 참조변수의 타입에 영향을 받는다.(참조변수의 타입이 조상이면 조상 클레스 친구를, 자손이면 자손 클레스 친구를
		  가져온다.) 
		  -<<<< 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다. >>>>
		  
		  
		  14.매개변수의 다형성
		   - 참조변수의 다형적인 특징은 매서드의 매개변수에도 적용된다.
		   -ex) ProductTest
		  
		  15.여러객체 배열 , Vector
		   - 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		   - Vector
		     : 배열을 사용할 경우 전체 크기를 한번 정하면 변경할 수 없다.
		       이를 Vector class를 이용하여 해결할 수 있다.
		   - 동적으로 크기가 관리되는 객체배열 이라고 할 수 있다.
		   
		   Vector v = new Vector();
		   Vector() 	: 10개의 객체를 저장할 수 있는 Vector Instance를 생성한다.
		   add()    	: Vector에 객체를 추가할 때 사용하는 method
		   remove() 	: Vector에서 객체를 제거할 때 사용하는 method
		   isEmpty()	: Vector에 객체를 가지고 있는지 확인하는 것. true false
		   contains(d)   : Vector 안에 찾으려는 값d(혹은 주소)가 있는지 확인하는 것.
		   Object  get(int index) : index번째 객체를 반환한다. (타입은 object)
		   int size()   : Vector에 객체가 저장된 개수를 반환한다.
		   
		   
		  16.추상클레스(abstract class)
		   - 미완성된 클레스 : 미완성된 메서드(추상 메서드)를 가지고 있다는 의미.
		   - 구성
		   		abstrackt class 클레스명{
		   			    
		   		}
		   - 추상 메서드
		     :메서드는 선언부와 구현부로 구성되어 있다.
		     :이때 추상 메서드 선언부만 작성되어 있고, 구현부는 작성되지 않은 매서드를 의미한다.
		     abstract 리턴타입 매서드명 ();
		     ex) class AbstractTest01
		     
		   -추상 클레스로부터 상속받는 자손 클레스는 오버라이딩을 통해 조상인 클레스의 추상 메서드를
		   	구현해주면 된다.
		   
		   
		 17. 인터페이스 (interface)
		 	-일종의 추상클레스이지만 추상 메서드(만)와 상수만을 멤버로 받는다.
		    -인터페이스 작성
		     interface 인터페이스명{
		     	public static final 변수타입 변수명 = 값; -> 상수
		     	public abstract 반환타입 메서드명(매개변수 타입  명, .... );(혹은 매개변수가 없어도 무방하다)
		     	
		     	
		     }
		     
		     :인터페이스 내의 모든 멤버변수는 public static final 이어야 한다.   ==  생략이 가능하다. (인터페이스 내의 '변수타입 변수 = 값' = 상수)
		     :인터페이스 내의 모든 메서드는 public abstract 이어야한다. == 생략이 가능하다 ( '반환타입 메서드명 (매개변수 변수명, ....) 
		    
		    -인터페이스의 상속
		     :인터페이스는 인터페이스만 상속받을 수 있다.
		      => 구현된 메서드를 상속받으면 더이상 interface가 아니게 되므로 클레스를 상속받을 수는 없다.
		     :인터페이스는 다중 상속이 가능하다. 인터페이스 내에 구현부가 없기 때문에 다중상속이 가능하다.
		     :Object와 같은 최고 조상은 없다.
		     
		    -인터페이스의 구현
		     :자체로는 인스턴스를 생성할 수 없다.(구현부가 없기 때문에 생성자가 없다.)
		     :자신이 정의된 추상메서드의 몸통을 만들어주는 클레스를 작성해야한다.(구현하다 = implements)
		     :클레스의 확장(extends) , 인터페이스의 구현(implements)
		     :~able,
		       =>Movable
		       => IMove  - > IMoveImpl <-직관적인 이름짓기 규칙.
		       ex)InterfaceTest
		     
		    -인터페이스의 다형성 
		     :인터페이스 타입의 참조변수로 그를 구현한 구현체(implements)의 인스턴스를 참조할 수 있다.
		    -인터페이스의 장점
		     :개발시간을 단축 할 수 있다.
		     :표준화가 가능하다.(만드는 프로그램의 기준) - > 독주석을 적극 활용하라. 
		     :서로 관계가 없는 클레스들에게 관계를 맺어줄 수 있다.
		     :독립적인 프로그래밍이 가능하다.
		     :7-26예제는 꼭 해보자. 이해하는데 아주 좋다.
		     
		    -인터페이스의 이해
		     :클레스를 사용하는 쪽(user)과 클레스를 제공하는 쪽(provider)이 있다.
		      A(Provider)(제공자) - I(선언부) - B(User) (구현) 
		  
		  18. 내부 클레스(inner class)
		     - 내부클레스란?
		       :클레스 내에 선언된 클레스
		       :서로 쉽게 접근할 수 있고, 외부에서 볼때 불필요한 클레스를 감춤으로
		            복잡성을 줄일 수 있다.
		        
		        
		     - 인스턴스 클레스 <응 잘 안써>
		     	:외부클레스의 인스턴스 맴버들과 관련된 작업을 수행한다.
 		     - 스테틱 클레스 <응 잘 안써>
 		        :외부클레스의 클레스 맴버들과 관련된 작업을 수행한다. 특히 클레스 메서드와 관련된 작업을 수행한다.
		     - 지역 클레스 <응 잘 안써>
		     	:외부클레스의 메서드나 초기화블럭 안에 선언된다. 선언 영역(초기화블럭 내) 내에서만 사용 가능하다.
		     	ex)InnerEx01, InnerEx02
		     - 익명 클레스<<젤 중요>>
		        : 클레스의 선언과 객체의 생성을 동시에 진행한다.
		        : 이름이 없는 클레스(일회용)
		        
		     
		     
		    
		     
'		     
		     
		     
		     
		     
		     
		     
		     
		     
		     
		     
		     
		     
		     		
		   
		   		   
		  
		 */
		  
	}

}
